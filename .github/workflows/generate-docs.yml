name: Generate Docs from Issues

on:
    issues:
        types: [opened, edited, closed, reopened, labeled, unlabeled]
    workflow_dispatch:

concurrency:
    group: docs-sync
    cancel-in-progress: false

jobs:
    generate-docs:
        runs-on: ubuntu-latest
        permissions:
            contents: write
            issues: read

        steps:
            - name: Checkout repo
              uses: actions/checkout@v4
              with:
                  token: ${{ secrets.GITHUB_TOKEN }}
                  fetch-depth: 0

            - name: Configure Git
              run: |
                  git config user.name "github-actions[bot]"
                  git config user.email "github-actions[bot]@users.noreply.github.com"

            - name: Generate Todo and Changelog
              uses: actions/github-script@v7
              with:
                  script: |
                      const fs = require('fs');
                      const path = require('path');

                      // Get current date
                      const now = new Date();
                      const dateStr = now.toLocaleDateString('en-GB', { 
                        day: '2-digit', 
                        month: '2-digit', 
                        year: 'numeric' 
                      });

                      // Read counter files and get CURRENT numbers (not next)
                      const trackingDir = '.tracking';
                      const changelogCounterFile = path.join(trackingDir, '.changelog_counter');
                      const todoCounterFile = path.join(trackingDir, '.todo_counter');

                      let changelogNum = 1;
                      let todoNum = 1;

                      // Read current counter values
                      if (fs.existsSync(changelogCounterFile)) {
                        const counterValue = parseInt(fs.readFileSync(changelogCounterFile, 'utf8').trim());
                        changelogNum = counterValue > 1 ? counterValue - 1 : 1;
                      }
                      if (fs.existsSync(todoCounterFile)) {
                        const counterValue = parseInt(fs.readFileSync(todoCounterFile, 'utf8').trim());
                        todoNum = counterValue > 1 ? counterValue - 1 : 1;
                      }

                      console.log(`Current changelog commit: #${changelogNum}`);
                      console.log(`Current todo commit: #${todoNum}`);

                      // Fetch all issues
                      const { data: issues } = await github.rest.issues.listForRepo({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        state: 'all',
                        per_page: 100
                      });

                      // Filter out pull requests
                      const actualIssues = issues.filter(issue => !issue.pull_request);

                      // Categorize issues
                      const categories = {
                        'backend': { icon: 'ðŸ”™', title: 'Backend', open: [], closed: [] },
                        'frontend': { icon: 'ðŸ–¼ï¸', title: 'Frontend', open: [], closed: [] },
                        'deployment': { icon: 'ðŸ”§', title: 'Deployment / Environment', open: [], closed: [] },
                        'extras': { icon: 'ðŸ§©', title: 'Extras / UI', open: [], closed: [] }
                      };

                      actualIssues.forEach(issue => {
                        const labels = issue.labels.map(l => l.name.toLowerCase());
                        let category = 'extras';
                        
                        if (labels.includes('backend')) category = 'backend';
                        else if (labels.includes('frontend')) category = 'frontend';
                        else if (labels.includes('deployment') || labels.includes('environment')) category = 'deployment';
                        
                        if (issue.state === 'open') {
                          categories[category].open.push(issue);
                        } else {
                          categories[category].closed.push(issue);
                        }
                      });

                      // Generate Todo.md
                      let todoContent = "# TODO\n\n";
                      todoContent += "Tracks tasks per commit. Snapshot copies are stored in [`.tracking/todos/`](./.tracking/todos/).\n\n";
                      todoContent += "To check the current changelog see the [Project's Changelog](./Changelog.md) file, with snapshots stored in [`.tracking/changelogs/`](./.tracking/changelogs/).\n\n";
                      todoContent += "---\n\n";
                      todoContent += `## Current Commit: #${todoNum} - ${dateStr}\n\n`;

                      // Add open issues by category
                      for (const [key, cat] of Object.entries(categories)) {
                        if (cat.open.length > 0) {
                          todoContent += `\n### ${cat.icon} ${cat.title}\n\n`;
                          cat.open.forEach(issue => {
                            todoContent += `-   [ ] ${issue.title} [#${issue.number}](${issue.html_url})\n`;
                            if (issue.body && issue.body.trim()) {
                              const bodyLines = issue.body.split('\n').filter(line => line.trim()).slice(0, 3);
                              bodyLines.forEach(line => {
                                if (line.trim() && line.trim().startsWith('-')) {
                                  todoContent += `    ${line.trim()}\n`;
                                }
                              });
                            }
                          });
                        }
                      }

                      // Check if there are no open issues in any category
                      const hasOpenIssues = Object.values(categories).some(cat => cat.open.length > 0);
                      if (!hasOpenIssues) {
                        todoContent += `\n### ðŸ”™ Backend\n\n> There are no new tasks for this section currently.\n`;
                        todoContent += `\n### ðŸ–¼ï¸ Frontend\n\n> There are no new tasks for this section currently.\n`;
                        todoContent += `\n### ðŸ”§ Deployment / Environment\n\n> There are no new tasks for this section currently.\n`;
                        todoContent += `\n### ðŸ§© Extras / UI\n\n> There are no new tasks for this section currently.\n`;
                      }

                      // Add completed table
                      todoContent += `\n### âœ”ï¸ Completed\n\n---\n\n| Commit # | Date Completed | Type | Description |\n| --- | --- | --- | --- |\n`;

                      // Add closed issues to completed table
                      const allClosed = [];
                      for (const [key, cat] of Object.entries(categories)) {
                        cat.closed.forEach(issue => {
                          const closedDate = issue.closed_at ? new Date(issue.closed_at).toLocaleDateString('en-GB', { 
                            day: '2-digit', 
                            month: '2-digit', 
                            year: 'numeric' 
                          }) : dateStr;
                          
                          allClosed.push({
                            issue,
                            date: closedDate,
                            category: cat,
                            key: key
                          });
                        });
                      }

                      // Sort by closed date (newest first)
                      allClosed.sort((a, b) => new Date(b.issue.closed_at) - new Date(a.issue.closed_at));

                      // Group closed issues by date to assign snapshot numbers
                      const closedByDate = {};
                      allClosed.forEach(item => {
                        if (!closedByDate[item.date]) {
                          closedByDate[item.date] = [];
                        }
                        closedByDate[item.date].push(item);
                      });

                      // Assign snapshot numbers
                      const dates = Object.keys(closedByDate).sort((a, b) => {
                        const [dayA, monthA, yearA] = a.split('/');
                        const [dayB, monthB, yearB] = b.split('/');
                        return new Date(yearB, monthB - 1, dayB) - new Date(yearA, monthA - 1, dayA);
                      });

                      let currentSnapNum = Math.max(changelogNum, todoNum);
                      const dateToSnapNum = {};
                      dates.forEach(date => {
                        dateToSnapNum[date] = currentSnapNum;
                        currentSnapNum = Math.max(1, currentSnapNum - 1);
                      });

                      allClosed.forEach(({ issue, date, category, key }) => {
                        const snapshotType = (key === 'backend' || key === 'frontend') ? 'changelogs' : 'todos';
                        const snapshotFile = snapshotType === 'changelogs' ? 'Changelog' : 'Todo';
                        const snapshotNum = dateToSnapNum[date];
                        
                        const snapshotLink = `[\`${snapshotNum}\`](./.tracking/${snapshotType}/${snapshotFile}#${snapshotNum}.md)`;
                        todoContent += `| ${snapshotLink} | ${date} | \`${category.icon} ${category.title}\` | [${issue.title}](${issue.html_url}) |\n`;
                      });

                      todoContent += `\n> Synced at ${now.toUTCString()}\n`;

                      // Write Todo.md
                      fs.writeFileSync('Todo.md', todoContent);

                      // Generate Changelog.md
                      let changelogContent = "# Changelog\n\n";
                      changelogContent += "All notable changes to this project are documented here. Commit-level tracking is used, with snapshots stored in [`.tracking/changelogs/`](./.tracking/changelogs/).\n\n";
                      changelogContent += "To see the todo list check the [Project Todo](./Todo.md) file, with snapshots stored in [`.tracking/todos/`](./.tracking/todos/).\n\n";
                      changelogContent += "The following tags are used throughout the changelog to categorize changes based on frontend and backend sides:<br> `[ðŸ–¼ï¸ Frontend]` `[ðŸ”™ Backend]`\n\n";
                      changelogContent += "---\n\n";
                      changelogContent += `## ðŸ› ï¸ Current Commit #${changelogNum} - ${dateStr}\n\n`;

                      // Group closed issues by type for changelog
                      const changeTypes = {
                        'added': { title: 'âž• Added', issues: [] },
                        'changed': { title: 'ðŸ·ï¸ Changed / Modified', issues: [] },
                        'fixed': { title: 'ðŸ©¹ Fixed', issues: [] },
                        'removed': { title: 'âž– Removed', issues: [] }
                      };

                      allClosed.forEach(({ issue, category }) => {
                        const labels = issue.labels.map(l => l.name.toLowerCase());
                        let changeType = 'changed';
                        
                        if (labels.includes('enhancement') || labels.includes('feature')) changeType = 'added';
                        else if (labels.includes('bug') || labels.includes('fix')) changeType = 'fixed';
                        else if (labels.includes('removed') || labels.includes('deprecated')) changeType = 'removed';
                        
                        changeTypes[changeType].issues.push({ issue, category });
                      });

                      // Write changelog sections
                      let hasAnyChanges = false;
                      for (const [key, section] of Object.entries(changeTypes)) {
                        if (section.issues.length > 0) {
                          hasAnyChanges = true;
                          changelogContent += `\n### ${section.title}\n\n`;
                          section.issues.forEach(({ issue, category }) => {
                            changelogContent += `-   **[${issue.title}](${issue.html_url})** \`[${category.icon} ${category.title}]\`\n`;
                            if (issue.body && issue.body.trim()) {
                              const firstLine = issue.body.split('\n').find(line => line.trim());
                              if (firstLine) {
                                changelogContent += `    ${firstLine.trim()}\n`;
                              }
                            }
                            changelogContent += `\n`;
                          });
                        }
                      }

                      if (!hasAnyChanges) {
                        changelogContent += `\n### âž• Added\n\n> No changes in this commit.\n`;
                      }

                      changelogContent += `\n---\n`;

                      // Write Changelog.md
                      fs.writeFileSync('Changelog.md', changelogContent);

                      console.log('Generated Todo.md and Changelog.md successfully!');

            - name: Commit and push changes
              run: |
                  git add Todo.md Changelog.md

                  if git diff --staged --quiet; then
                    echo "No changes to commit"
                    exit 0
                  fi

                  git commit -m "docs: regenerate from issues"

                  # Retry push with pull if needed
                  MAX_RETRIES=3
                  RETRY_COUNT=0

                  while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                    if git push origin HEAD:main; then
                      echo "Push successful"
                      exit 0
                    else
                      echo "Push failed, pulling and retrying..."
                      git pull --rebase origin main
                      RETRY_COUNT=$((RETRY_COUNT + 1))
                    fi
                  done

                  echo "Failed to push after $MAX_RETRIES attempts"
                  exit 1
